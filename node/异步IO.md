- 异步I/O 必要性
  - 期望 I/O 的调用不阻塞后续运算，时间和资源分配给其他需要的业务执行
  - 更快的性能以及更好的用户体验
    - 非阻塞
      - 单线程下计算时不阻塞 UI 线程渲染导致的页面卡顿
    - 并行
      - 客户端可以同时请求多个资源，时间消耗从各个资源的消耗综合变为最耗时的一个资源的时间
    - 分布式常态提供更好支持
      - 复杂多服务应用，提高后端服务资源快速响应，前端体验才能更好

- 不同 I/O 类型对应的开销：cpu 时钟周期
  - cpu 一级缓存:   3
  - cpu 二级缓存:   14
  - 内存：          250
  - 硬盘：          41000000
  - 网络：          240000000

- 单线程 or 多线程
  - 创建多线程的开销 小于 并行执行的开销
    - 首选多线程
      - 多线程可以提升多核浏览器的 cpu 的利用率
      - 多线程的代价在于创建线程和执行期上下文切换的开销较大
      - 复杂业务，多线程面临 锁 状态同步 等问题

- node
  - 利用单线程，避免死锁，多线程状态同步
  - 利用异步I/O，让单线程避免阻塞，更好利用 cpu
  - 利用 child_process 子进程，子进程更高效的利用多核 cpu

- 阻塞I/O
  - 系统内核层面完成所有操作后，调用才结束，返回数据
    - 系统内核完成磁盘寻道、读取数据、复制数据到内存中
  - 造成 cpu 等待 I/O 操作，浪费等待时间

- 非阻塞I/O
  - 调用后立即返回
    - 仅返回当前的调用状态
  - 轮询重复 I/O 操作来确认是否完成，获取完整的数据
    - 让 cpu 处理状态判断，对 cpu 资源的浪费
    - 轮询技术演进，减少损耗
      - read
      - select
      - poll
      - epoll
        - 利用事件通知、执行回调的方式，并非之前的遍历查询，不会浪费 cpu，执行效率较高
      - kqueue
        - 类似 epoll ，不过仅在 FreeBSD 系统下存在
    - 轮询技术满足 非阻塞I/O 确保获取完整数据的需求，对于应用程序，仍只算是一种同步，须花事件等待完整数据返回
      - 等待期间，cpu 要么遍历文件描述符的状态，要么处于休眠期

- 异步非阻塞I/O
  - 尽管轮询演进技术 epoll 已经使用事件来降低 cpu 损耗，但是存在休眠期，休眠期时闲置的
  - 单线程理想下的异步I/O
    - 发起非阻塞调用后，可以去处理其他任务，通过信号或回调把数据传递给应用程序
      - 目前只存在 Linux 下的一种 AIO 的方式
  - 单线程现实的异步I/O
    - 用额外线程去实现发起调用，轮询获取完整数据，通过线程通信把数据传递回来，模拟异步I/O
      - 线程池模拟异步I/O

- Node 中的 异步 I/O
  - 事件循环
    - 进程启动时，Node 创建一个 类似 while(true) 的循环，执行一次循环成为 Tick
      - 每个 Tick 的过程查看是否有待处理的事件
        - 如果有就取出事件以及回调函数，如果存在关联的回调函数就执行，然后进入下一个循环
        - 如果不再有事件需要处理，就退出流程
    - Tick
      - 每个 Tick 通过 观察者 判断是否有事件需要处理
      - 观察者
        - 每个事件循环都会有一个或多个观察者，判断是否有事件要处理，就是向这些观察者询问是否有事件要处理
        - 浏览器采用类似的机制
          - 事件来源于用户点击或加载某个文件，产生的事件都有对应的观察者
            - 类似 定时器线程 事件线程 网络请求线程
        - 网络请求、文件I/O 等事件为 Node 提供不同类型的事件，传递到不同的观察者，事件循环从观察者那里取事件执行
    - window 下基于 IOCP
      - 内部仍是线程池原理，不同之处在于这些线程池由系统内核接手管理
    - *nux 下基于线程池

- 非 I/O 的异步 api
  - setTimeout、setInterval、setImmediate
    - 不需要线程池的参与，被相关观察者收集
    - 每次 Tick 执行时，迭代出一个定时器对象，检查是否超过事件，超出则形成一个事件，被获取执行
  - process.nextTick
    - 微任务队列

# 原型

```
function F (){}
var f = new F()
// Object.getPrototypeOf 获取对象的原型对象
Object.getPrototypeOf(f) === F.prototype // true
Object.getPrototypeOf(f) === Object.prototype // false
f instanceof F // true
f instanceof Object // true
Foo[Symbol.hasInstance](foo) 相当于是 f instanceof Object

var f1 = Object.setPrototypeOf({}, F.prototype || Object.getPrototypeOf(f)) // setPrototypeOf
var f1 = Object.create(F.prototype || Object.getPrototypeOf(f))

// 浅拷贝对象带有数据的完整描述的方法
var newObj = Object.create(Object.getPrototypeOf(f), Object.getOwnPropertyDescriptors(f))
```

# 继承

```
function A () {}
function B () {}
----------------------
B.prototype = new A()
var b = new B()
// A 的实例中有引用对象属性时，B 的所有实例用到这些引用对象属性时会相互影响
----------------------
----------------------
B.prototype = Object.create(A.prototype)
var b = new B()
----------------------

```

# class: 类的写法

```
class ClassPoint {
  constructor(x, y) {
    // ...
  }

  toString() {
    // ...
  }
}
```

## 相当于

```
var Point = function (x, y) {
  // ...
};

Point.prototype.toString = function () {
  // ...
};
```

## 区别

```
class 定义的构造函数
  不存在变量提升  声明之前使用会报错
  不能像function 构造函数可以直接当成方法执行，只能 new 调用 直接执行报错 TypeError
  class 中声明的箭头函数 () => {} 会直接实例化为 实例的 自身属性  不会出现在原型链上

// toString()方法是Point类内部定义的方法，它是不可枚举的。这一点与 ES5 的行为不一致。
Object.keys(ClassPoint.prototype) // []
Object.keys(Point.prototype) // ["toString"]
Object.getOwnPropertyNames(ClassPoint.prototype) // ["constructor","toString"]
Object.getOwnPropertyNames(Point.prototype) // ["constructor","toString"]
```

## super

# 原型

```
function F (){}
var f = new F()
// Object.getPrototypeOf 获取对象的原型对象
Object.getPrototypeOf(f) === F.prototype // true
Object.getPrototypeOf(f) === Object.prototype // false
f instanceof F // true
f instanceof Object // true
Foo[Symbol.hasInstance](foo) 相当于是 f instanceof Object

var f1 = Object.setPrototypeOf({}, F.prototype || Object.getPrototypeOf(f)) // setPrototypeOf
var f1 = Object.create(F.prototype || Object.getPrototypeOf(f))

// 浅拷贝对象带有数据的完整描述的方法
var newObj = Object.create(Object.getPrototypeOf(f), Object.getOwnPropertyDescriptors(f))
```

# 继承

```
function A () {}
function B () {}
----------------------
B.prototype = new A()
var b = new B()
// A 的实例中有引用对象属性时，B 的所有实例用到这些引用对象属性时会相互影响
----------------------
----------------------
B.prototype = Object.create(A.prototype)
var b = new B()
----------------------

```

# class: 类的写法

```
class ClassPoint {
  constructor(x, y) {
    // ...
  }

  toString() {
    // ...
  }
}
```

## 相当于

```
var Point = function (x, y) {
  // ...
};

Point.prototype.toString = function () {
  // ...
};
```

## 区别

```
class 定义的构造函数
  不存在变量提升  声明之前使用会报错
  不能像function 构造函数可以直接当成方法执行，只能 new 调用 直接执行报错 TypeError
  class 中声明的箭头函数 () => {} 会直接实例化为 实例的 自身属性  不会出现在原型链上

// toString()方法是Point类内部定义的方法，它是不可枚举的。这一点与 ES5 的行为不一致。
Object.keys(ClassPoint.prototype) // []
Object.keys(Point.prototype) // ["toString"]
Object.getOwnPropertyNames(ClassPoint.prototype) // ["constructor","toString"]
Object.getOwnPropertyNames(Point.prototype) // ["constructor","toString"]
```

## super
## extends继承的派生类 须用 super 关键字执行构造实例，必须先调用super()之后才能使用this
```
class A {
  constructor() {}
}
class B extends A {
  constructor() {
    super()
    this.xxx ....
  }
}
```
```
子类方法中使用 super 调用父类原型的方法，此时 super 指向父类的原型对象
  https://zh.javascript.info/class-inheritance
  super.xxx() 类似相当于 this.__proto__.xxx.call(this)，但原理比这个复杂，this.__proto__.call(this) 深层次继承 子类的子类会出现死循环
  为了提供解决方法，JavaScript 为函数添加了一个特殊的内部属性：[[HomeObject]]。
    当一个函数被定义为类或者对象方法时，它的 [[HomeObject]] 属性就成为了该对象。
    然后 super 使用它来解析（resolve）父原型及其方法。
    正如我们之前所知道的，函数通常都是“自由”的，并没有绑定到 JavaScript 中的对象。正因如此，它们可以在对象之间复制，并用另外一个 this 调用它。
    [[HomeObject]] 的存在违反了这个原则，因为方法记住了它们的对象。[[HomeObject]] 不能被更改，所以这个绑定是永久的。
    在 JavaScript 语言中 [[HomeObject]] 仅被用于 super。所以，如果一个方法不使用 super，那么我们仍然可以视它为自由的并且可在对象之间复制。但是用了 super 再这样做可能就会出错。
  
子类方法中使用 super 调用父类的静态 static 的方法，此时 super 指向父类本身
```
```
常规构造函数和派生构造器的不同： 派生构造器具有特殊的内部属性 [[ConstructorKind]]:"derived"。这是一个特殊的内部标签。
当通过 new 执行一个常规构造函数时，它将创建一个空对象，并将这个空对象赋值给 this。
但是当派生构造器的 constructor 执行时，它不会执行此操作。它期望父类的 constructor 来完成这项工作
派生的 constructor 必须调用 super 才能执行其父类（base）的 constructor，否则 this 指向的那个对象将不会被创建。并且我们会收到一个报错。
派生类构造器不声明 constructor 属性方法，相当于一个里面只有 super(...args) 的空构造器。派生类构造器实例化时会直接执行父类的 constructor()
```

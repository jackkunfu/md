# 三次握手

```
客户端发送请求序列号 syn 以及 随机生成一个 seq:random_seq_client

服务器接收到 客户端(syn seq) 信息后回复 ack = random_seq_client + 1 以及 服务端 随机生成一个 seq:random_seq_server

客户端接收到 服务端(ack seq) 信息后不随机生成了 回复 ack = random_seq_server + 1 以及 seq = ack
```

```
（1）客户端处于FIN_WAIT_1状态
（2）服务端收到fin，回复ack后为CLOSE_WAIT状态，发送fin后为LAST_ACK状态
（3）客户端收到fin后为FIN_WAIT_2状态，发送ack后为TIME_WAIT状态
（4）若客户端在一定时间内没有继续收到服务端的fin，则说明正确关闭连接了，否则继续发送ack，若连接关闭，则都为CLOSED状态。
```

# ssl 握手协议

```
（1）客户端发送其支持的算法列表和客户端随机数
（2）服务端返回选择的算法，服务端证书（包含服务端的公钥），服务端随机数
（3）客户端验证证书，提取公钥，生成预主密钥，用服务端公钥加密，发送给问服务端
（4）客户端和服务端用预主密钥和2个随机数计算出加密密钥和mac密钥和初始向量
（5）客户端发送一个针对所有握手信息的mac
（6）服务端发送一个针对所有握手信息的mac

使用随机数是为了预防重放攻击，防止中间人记录一次握手记录，下次通过这个记录模拟和服务端握手
最后2步发送mac是为了查看握手过程是否收到篡改
```

# https://zhuanlan.zhihu.com/p/29724438

# https://zhuanlan.zhihu.com/p/24860273

- 各层相关协议

  - 应用层
    - http/ftp/dns
  - 传输层
    - tcp/udp
  - 网络层
    - ip/arp(AddressResolution Protocol 地址解析)/rarp(反向地址解析)
  - 数据链路层

- TCP

  - 为了更容易传送大数据，把数据分割成以报文段（segment）为单位的数据包，tcp 包头的最小字节为 20 字节
  - 三次握手（three-way handshaking）
    - 发送端首先发送一个带 SYN 标志的数据包给对方
    - 接收端收到后，回传一个带有 SYN/ACK 标志的数据包以示传达确认信息
    - 最后，发送端再回传一个带 ACK 标志的数据包，代表“握手”结束。
    - 若在握手过程中某个阶段莫名中断，TCP 协议会再次以相同的顺序发送相同的数据包。
  - 四次挥手
    - 客户端发送 fin 给服务端
    - 服务端收到 fin 之后，回复 ack 关闭连接
    - 服务端发送 fin 给客户端
    - 客户端收到 fin 之后回复 ack

- UDP

  - 非连接的协议，传输数据不建立连接，因此也就不需要维护连接状态
    - 不保证数据包的顺序正确以及数据包的完整
    - 设计的目的：希望以最小的开销来达到网络环境中的进程通信目的。
  - UDP 信息包的标题很短，只有 8 个字节，相对于 TCP 的 20 个字节信息包的额外开销很小。
  - UDP 是面向报文的。发送方的 UDP 对应用程序交下来的报文， 在添加首部后就向下交付给 IP 层
    - 既不拆分，也不合并，而是保留这些报文的边界， 因此，应用程序需要选择合适的报文大小。
  - ping 命令的原理就是通过 IP 协议和 ICMP 协议发送 udp 报文

- tcp/ip 协议族，协议间关系

  - 输入地址之后，首先 dns 协议把浏览地址中的域名转换成 ip 地址
  - http 协议根据具体请求的资源路径，生成具体请求的请求报文
  - tcp 协议为了方便传输，将 http 请求报文按序号分割为带有序号的多个报文段
  - ip 协议搜索对方地址，并中转传送报文段
    - arp 协议，根据 IP 地址获取 MAC 地址的一种协议
  - 服务端接收到报文段数据后，tcp 协议按序号以原来的顺序重组到达的报文段，重组成请求报文
  - 服务端重组完成请求报文之后，http 协议处理请求
  - 请求的结果以 tcp / ip 流程返回给客户端

- 对称加密

  - 又叫私钥加密，即信息的发送方和接收方使用同一个密钥去加密和解密数据
  - 对称加密的特点是算法公开、加密和解密速度快，适合于对大数据量进行加密
  - 对称加密算法：DES、3DES、TDEA、Blowfish、RC5 和 IDEA

- 非对称加密

  - 又叫公钥加密，
  - 被公钥加密过的密文只能被私钥解密
    - 明文 + 加密算法 + 公钥 => 密文， 密文 + 解密算法 + 私钥 => 明文
  - 被私钥加密过的密文只能被公钥解密
    - 明文 + 加密算法 + 私钥 => 密文， 密文 + 解密算法 + 公钥 => 明文
  - 非对称加密算法：RSA、Elgamal、Rabin、D-H、ECC

- 数字证书

  - 非对称密码学的原理，每个证书持有人都有一对公钥和私钥
  - 数字证书则是由证书认证机构（CA）对证书申请者真实身份验证之后
  - 用 CA 的根证书对申请人的一些基本信息以及申请人的公钥进行签名（相当于加盖发证书机构的公章）后形成的一个数字文件。
  - 数字证书就是经过 CA 认证过的公钥
  - 私钥一般情况都是由证书持有者在自己本地生成的，由证书持有者自己负责保管

- HTTPS

  - https://www.jianshu.com/p/14cd2c9d2cd2
  - HTTPS 协议 = HTTP 协议 + SSL/TLS 协议
    - SSL/TLS 对数据进行加解密
    - HTTP 对加密后的数据进行传输
  - 为了兼顾安全与效率，同时使用了对称加密和非对称加密
    - 对数据进行对称加密
    - 对称加密所要使用的密钥通过非对称加密
  - 涉及到的三个密钥
    - 服务端的公钥和私钥，用来非对称加解密
    - 客户端随机生成的密钥，用来对称加解密
  - 一个 HTTPS 请求实际上包含了两次 HTTP 传输，步骤

    - 客户端发起 https 请求，访问服务端 443 端口
    - 服务端有密钥对，即公钥和私钥，把公钥证书发给客户端
    - 收到服务器端的证书之后，会对证书进行检查，验证其合法性
      - 如果发现发现证书有问题，那么 HTTPS 传输就无法继续。
      - 如果公钥合格，那么客户端会生成一个随机值，这个随机值就是用于进行对称加密的密钥，
    - 然后用服务器的公钥对客户端密钥进行非对称加密，这样客户端密钥就变成密文了
    - HTTPS 中的第一次 HTTP 请求结束。
    - 客户端会发起 HTTPS 中的第二个 HTTP 请求，将加密之后的客户端密钥发送给服务器
    - 服务器接收到客户端发来的密文之后，会用自己的私钥对其进行非对称解密，得到客户端密钥
    - 然后用客户端密钥对数据进行对称加密，把加密后的密文发送给客户端
    - 客户端接收到加密数据，用客户端密钥对其进行对称解密，得到服务器发送的数据

    - 访问服务端 443 端口，服务端把公钥证书发过来，客户端验证通过后，随机生成一个客户端密钥
    - 客户端密钥对数据进行对称加密，再把客户端密钥进行非对称加密，传输给服务端，服务端用私钥非对称解密获取客户端密钥
    - 服务端用解密后的客户端密钥把需要返回的数据对称加密发送给客户端

## https://www.cnblogs.com/TomXu/archive/2012/01/16/2309728.html

# 变量对象： VO

```
如果变量与执行上下文相关，那变量自己应该知道它的数据存储在哪里，并且知道如何访问。这种机制称为变量对象(variable object)。
activeExecutionContext = {
  VO: {
    // 上下文数据（var, FD, function arguments)
  }
};
VO 就是执行上下文的属性
在全局上下文里，全局对象自身就是变量对象
在具体实现层面(以及规范中)变量对象只是一个抽象概念。(从本质上说，在具体执行上下文中，VO名称是不一样的，并且初始结构也不一样。
```

## 包括：

```
变量 (var, 变量声明);
函数声明 (FunctionDeclaration, 缩写为FD);
函数的形参
```

```
var a = 10; // 全局上下文中的变量

(function () {
  var b = 20; // function上下文中的变量
})();
```

## 全局对象

```
全局对象(Global object) 是在进入任何执行上下文之前就已经创建了的对象；
这个对象只存在一份，它的属性在程序中任何地方都可以访问，全局对象的生命周期终止于程序退出那一刻。
```

# 函数上下文中的活动对象：AO activation object

## 函数执行上下文中，VO 是不能直接访问的，此时由活动对象(activation object,缩写为 AO)扮演 VO 的角色。

## 活动对象是在进入函数上下文时刻被创建的，它通过函数的 arguments 属性初始化。arguments 属性的值是 Arguments 对象：

```
AO = {
  arguments: <Arguments>
};
```

## Arguments 对象是活动对象的一个属性，它包括如下属性：

```
callee — 指向当前函数的引用
length — 真正传递的参数个数
properties-indexes (字符串类型的整数) 属性的值就是函数的参数值(按参数列表从左到右排列)。 properties-indexes 内部元素的个数等于 arguments.length. properties-indexes 的值和实际传递进来的参数之间是共享的。
```

```
alert(x); // function

var x = 10;

alert(x); // 10

x = 20;

function x() {};

alert(x); // 20
```

```
foo(10, 20);
function foo(x, y, z) {
  // 声明的函数参数数量arguments (x, y, z)
  alert(foo.length); // 3

  // 真正传进来的参数个数(only x, y)
  alert(arguments.length); // 2

  // 参数的callee是函数自身
  alert(arguments.callee === foo); // true

  // 参数共享
  alert(x === arguments[0]); // true
  alert(x); // 10

  arguments[0] = 20;
  alert(x); // 20

  x = 30;
  alert(arguments[0]); // 30

  // 不过，没有传进来的参数z，和参数的第3个索引值是不共享的

  z = 40;
  alert(arguments[2]); // undefined

  arguments[2] = 50;
  alert(z); // 40
}
```

# 执行上下文的代码被分成两个基本的阶段来处理

### 进入执行上下文 和 执行代码

## 例如：

```
function test(a, b) {
  var c = 10;
  function d() {}
  var e = function _e() {};
  (function x() {});
}
```

## 进入执行上下文阶段

```
当进入执行上下文(代码执行之前)时，VO里已经包含了下列属性:
  函数的所有形参(如果我们是在函数执行上下文中)
    名称和对应值组成的一个变量对象的属性被创建
    没有传递对应参数的话，那么由名称和undefined值组成的一种变量对象的属性也将被创建。
  所有函数声明(FunctionDeclaration, FD)
    名称和对应值（函数对象(function-object)）组成一个变量对象的属性被创建
    如果变量对象已经存在相同名称的属性，则完全替换这个属性
  所有变量声明(var, VariableDeclaration)
    名称和对应值（undefined）组成一个变量对象的属性被创建
    如果变量名称跟已经声明的形式参数或函数相同，则变量声明不会干扰已经存在的这类属性。

  变量声明在顺序上跟在函数声明和形式参数声明之后，而且在这个进入上下文阶段，变量声明不会干扰VO中已经存在的同名函数声明或形式参数声明
```

```
AO(test) = {
  a: 10,
  b: undefined,
  c: undefined,
  d: <reference to FunctionDeclaration "d">
  e: undefined
};
AO里并不包含函数“x”。这是因为“x” 是一个函数表达式(FunctionExpression, 缩写为 FE) 而不是函数声明，函数表达式不会影响VO。 不管怎样，函数“_e” 同样也是函数表达式，但是就像我们下面将看到的那样，因为它分配给了变量 “e”，所以它可以通过名称“e”来访问。 函数声明FunctionDeclaration与函数表达式FunctionExpression 的不同
```

## 代码执行阶段

```
这个周期内，AO/VO已经拥有了属性(不过，并不是所有的属性都有值，大部分属性的值还是系统默认的初始值undefined )。
AO['c'] = 10;
AO['e'] = <reference to FunctionExpression "_e">;
FunctionExpression“_e”保存到了已声明的变量“e”上，所以它仍然存在于内存中
FunctionExpression “x”却不存在于AO/VO中
也就是说如果我们想尝试调用“x”函数，不管在函数定义之前还是之后，都会出现一个错误“x is not defined”
未保存的函数表达式只有在它自己的定义或递归中才能被调用。
```

```
一个重要的知识点。变量相对于简单属性来说，变量有一个特性(attribute)：{DontDelete},这个特性的含义就是不能用delete操作符直接删除变量属性。
不使用var声明的变量不会出现在VO/AO中，只是相当于给window增加了个属性，可以被delete处理
声明的变量属性不能被delete
一种情况声明的可以被删除：eval执行的语句，一些调试工具是可以delete的，因为比如firebug是用eval执行的，可以被删除，不具有{DontDelete}属性
a = 10;
alert(window.a); // 10

alert(delete a); // true

alert(window.a); // undefined

var b = 20;
alert(window.b); // 20

alert(delete b); // false

alert(window.b); // still 20
```
